%macro call_stoid 4
	mov  cl, %4
	mov rdx, %3
	mov rsi, %2
	mov rdi, %1
	call stoid
%endmacro


section .data
	Str1 db "42", 0
	Str2 db "-67", 0
	Str3 db "   -86", 0
	Str4 db "    129, 93", 0
	Str5 db 0
	Str6 db "1,2", 0
	Str7 db " garbage ", 0
	Str8 db 1, 2, 3, 4, 5, 0

section .bss
	Num1 resq 1
	Num2 resq 1
	Num3 resq 1
	Num4 resq 1
	Num5 resq 1
	Num6 resq 1
	Num7 resq 1
	Num8 resq 1

section .text
global stoid
global _start

stoid:
	; String to integer with character delimiter. This function ignores
	; any leading spaces as so generated by `itosfr'.
	; PARAM
	;     rdi = out int ptr (int64*)
	;     rsi = buf ptr (char*)
	;     rdx = str len, exclude null term (unsigned int64)
	;      cl = ASCII delimiter (char) @ [cl]
	; RETURN
	;     rax = ptr to next delimiter in `buf ptr' (0 on failure)
	push rbx
	push r12
	push r13

	; validation
	mov rax, 0
	cmp rdi, 0
	jz stoid_end

	cmp rsi, 0
	jz stoid_end

	cmp rdx, 0
	jz stoid_end

	; skip any spaces
	mov QWORD [rdi], 0
	mov rax, rsi ; use rax in case of empty string for easy return
	mov r11, rax
	add r11, rdx ; r11 points to end of `buf ptr'.
stoid_skip_space_loop:
	cmp rax, r11
	je stoid_end ; reached end of string
	cmp BYTE [rax], " "
	jne stoid_skip_space_loop_end
	inc rax
	jmp stoid_skip_space_loop
stoid_skip_space_loop_end:
	mov r10, rax ; rax will be used as the accumulator next

	; check for positive/negative sign
	mov r12, 1 ; 1 = positive, -1 = negative
	cmp BYTE [r10], "-"
	je stoid_negative
	cmp BYTE [r10], "+"
	je stoid_positive
	jmp stoid_nosign
stoid_negative:
	mov r12, -1
stoid_positive:
	inc r10
stoid_nosign:
	
	; load in the digits
	mov rbx, 10 ; base 10
	mov rax, 0
	mov r13, 0 ; clear upper 56 bits for character
stoid_digit_loop:
	cmp r10, r11
	je stoid_digit_loop_end
	mov r13b, BYTE [r10]
	cmp r13b, cl
	je stoid_digit_loop_end
	sub r13b, "0"
	; check for digit validity
	cmp r13b, 0
	jl stoid_digit_loop_end_invalid
	cmp r13b, 9
	jg stoid_digit_loop_end_invalid
	; otherwise, add it to number
	imul rax, rbx
	add rax, r13
	inc r10
	jmp stoid_digit_loop
stoid_digit_loop_end_invalid:
	mov rax, 0 ; now rax is the pointer which on failure is 0
	jmp stoid_end
stoid_digit_loop_end:
	; use r13 as intermediary for QWORD [rdi]
	mov r13, rax
	imul r13, r12
	mov QWORD [rdi], r13
	mov rax, r10 ; restore rax as buf pointer
	
stoid_end:
	pop r13
	pop r12
	pop rbx
ret

_start:
	call_stoid Num1, Str1,  3, 0
	call_stoid Num2, Str2,  4, 0
	call_stoid Num3, Str3,  6, 0
	call_stoid Num4, Str4, 11, ","
	call_stoid Num5, Str5,  0, 0
	call_stoid Num6, Str6,  3, ","
	call_stoid Num7, Str7,  9, 0
	call_stoid Num8, Str8,  5, 0

	; exit
	mov rax, 60
	mov rdi, 0
	syscall
